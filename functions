#!/bin/bash

# This file contains common functions for running MD

#==============================================================================

# Check for last run successful completion
# $1 = mdout file
# $2 = skeleton name to delete
# $3 = whether or not to return an error
# Example:
#   check_previous "Prod_1.mdout" "Prod_1"
# Deletes previous ones if error, kills self
# Creates a file called "failure" if a failure occured
function check_previous {
    if [[ -z "$3" ]]; then
        fail=1
    else
        fail=0
    fi
    error=0

    # Check for NaNs in mdinfo
    if [[ -f "mdinfo" ]]; then
        if $(grep -q "NaN" "mdinfo"); then
            echo "NaN in mdinfo!"
            error=1
        fi
    fi

    # Check for existence of mdout
    if [[ ! -f "$1" ]]; then
        echo "Mdout not found"
        error=1
    fi

    # Check for errors in previous trajectory
    if $(grep -q "NaN(s) found in input coordinates" "$1"); then
        echo "NaN in input coordinates"
        error=2
    # Check for Nans in mdout
    elif $(grep -q "NaN" "$1"); then
        echo "NaN in mdout!"
        error=2
    fi

    # Check for incomplete rst file
    # Replace error lines in slurm file so this doesn't repeatedly trigger
    badrst=$(grep "end-of-file during read" "${rev}slurm.out" | \
             tail -n 1 | awk '{print $NF}')
    if [[ ! -z $badrst ]]; then
        echo "Incomplete rst file!"
        sed -e "s/end-of-file during read/EOFERROR/g" -i "${rev}slurm.out"
        error=2
    fi

    # Check for cuda error as last line
    if $(tail -n 1 "${rev}slurm.out" | grep -qi "cuda.*gpubuffer"); then
        echo "Cuda crash!"
        error=2
    fi

    # Check for MPI error as last line
    if $(tail -n 1 "${rev}slurm.out" | grep -qi "mpi_abort"); then
        echo "MPI crash"
        error=2
    fi

    # Check for crash caused by previous coordinates
    # TODO

    # Delete previous one
    if [[ "$error" -eq 2 ]]; then
        if [[ "$2" == "Prod_0" ]]; then
            echo "Deleting Eq_6"
            rm -f "Eq_6".{nc,mdout.rst}
        elif [[ "$2" == "Eq_6" ]]; then
            echo "Deleting bad Eq_6"
            rm -f "Eq_6".{nc,mdout.rst}
            rm -f "mdinfo"
        elif [[ "$2" == *"Heat"* ]]; then
            echo "Deleting heating"
            rm -f "Heat"*.{nc,mdout,rst}
        else
            echo "Deleting previous: $prev"
            prev="Prod_$(($(echo "$2" | awk -F '_' '{print $NF}')-1))"
            rm -f "$prev".{nc,mdout.rst}
        fi
    fi

    if [[ "$error" -ne 0 ]]; then
        echo "Deleting $2"
        rm -f "$2".{nc,mdout,rst}
        rm -f "mdinfo"

        if [[ -f "failure" ]]; then
            echo "$(($(cat "failure")+1))" > "failure"
        else
            echo "1" > "failure"
        fi

        # Resubmit the job
        sbatch "PROTOCOL.sh"
        return $fail
    fi

    rm -f "failure"
    return 0
}

#==============================================================================

# Runs a single step
# $1 = step name
# $2 = restart file
# $3 = input file. If not provided, defaults to $inpdir/$1.mdin
# $4 = if present, don't chmod output files 
# Example:
#   run_md "Heat_2" "Heat_1.rst"
function run_md {
    if [[ -z $3 ]]; then
        inp="$inpdir/${1}.mdin"
    else
        inp=$3
    fi

    if [[ $SHERLOCK == 2 && $SLURM_NTASKS_PER_SOCKET == 1 ]]; then
        unset CUDA_VISIBLE_DEVICES # HACK HACK HACK
        $AMBERHOME/bin/pmemd.cuda \
        -O \
        -i "$inp" \
        -o "${1}.mdout" -p "$prmtop" -c "$2" \
        -r "${1}.rst" -ref "$ref" -x "${1}.nc"
    else
        $MPI_HOME/bin/mpirun -np $SLURM_NTASKS_PER_SOCKET \
                             --bind-to socket \
                             $AMBERHOME/bin/pmemd.cuda.MPI \
                             -O \
                             -i "$inp" \
                             -o "${1}.mdout" -p "$prmtop" -c "$2" \
                             -r "${1}.rst" -ref "$ref" -x "${1}.nc" \
                             -amd "${1}.amdlog"
    fi

    # Remove write permissions but don't fail if you can't
    if [[ -z "$4" ]]; then
        set +e
        chmod a-w -f "$1".{mdout,rst,nc}
        set -e
    fi
}

#==============================================================================

# Runs a single step, with 8 CPUs. Won't save a trajectory (for minimization)
# $1 = step name
# $2 = restart file
# $3 = input file. If not provided, defaults to $inpdir/$1.mdin
# Example:
#   run_md "min1" "init.rst" "$inpdir/01_min.mdin"
function run_md_min {
    if [[ -z $3 ]]; then
        inp="$inpdir/${1}.mdin"
    else
        inp=$3
    fi

    $MPI_HOME/bin/mpirun -np $SLURM_NTASKS \
                         --bind-to socket \
                         $AMBERHOME/bin/pmemd.MPI \
                         -O \
                         -i "$inp" \
                         -o "${1}.mdout" -p "$prmtop" -c "$2" \
                         -r "${1}.rst" -ref "$ref"
    # Remove write permissions but don't fail if you can't
    set +e
    chmod a-w -f "$1".{mdout,rst}
    set -e
}

#==============================================================================

# Prints out a summary of other things running on this node
# Hopefully this will help me debug why things are crashing all the time
function print_node_jobs {
    echo "-------------------------------"
    hn=${HOSTNAME%.local}
    echo "$hn   $(date)"
    squeue -w "$hn" -O "gres,numcpus,partition,username"
}

#==============================================================================
